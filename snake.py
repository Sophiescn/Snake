from fltk import *from time import sleepfrom random import randintdef case_vers_pixel(case):    """	Fonction recevant les coordonnées d'une case du plateau sous la	forme d'un couple d'entiers (ligne, colonne) et renvoyant les	coordonnées du pixel se trouvant au centre de cette case. Ce calcul	prend en compte la taille de chaque case, donnée par la variable	globale taille_case.    """    i, j = case    return (i + .5) * taille_case, (j + .5) * taille_casedef affiche_obstacles(obstacles):    """    affiche des obstacles dessiner par la fonction    """    for obstacle in obstacles:        x, y = case_vers_pixel(obstacle)        rectangle(x - taille_case / 2, y - taille_case /2, x + taille_case / 2,                  y + taille_case / 2,                  couleur='purple', remplissage='purple')def affiche_pommes(pommes): # liste de coordonées    """    affiche des pommes dessiner par la fonction    """    for pomme in pommes:        x, y = case_vers_pixel(pomme)        cercle(x, y, taille_case/2,               couleur='darkred', remplissage='red')        rectangle(x-2, y-taille_case*.4, x+2, y-taille_case*.7,                  couleur='darkgreen', remplissage='darkgreen')def affiche_serpent(serpent, couleur):    """    permet    d'affiche le serpent    """    for boule in range (len(serpent)):        x, y = case_vers_pixel(serpent[boule])  # à modifier !!!        cercle(x, y, taille_case/2 + 1,               couleur='dark' + couleur, remplissage=couleur)def change_direction(direction, touche):    """    permet de changer la direction    du joueur 1 en fonction de la touche    pressé et la direction precedente    """    if touche == 'Up' and direction != (0, 1):        # flèche haut pressé        return (0, -1)    elif touche == 'Down' and direction != (0, -1):        return (0, 1)    elif touche == 'Right' and direction != (-1, 0):        return (1, 0)    elif touche == 'Left' and direction != (1, 0):        return (-1, 0)    else:        # pas de changement !        return directiondef change_direction2(direction, touche):    """    permet de changer la direction    du joueur 2 en fonction de la touche    pressé et la direction precedente    """    if touche == 'z' and direction != (0, 1):        # flèche haut pressée        return (0, -1)    elif touche == 's' and direction != (0, -1):        return (0, 1)    elif touche == 'd' and direction != (-1, 0):        return (1, 0)    elif touche == 'q' and direction != (1, 0):        return (-1, 0)    else:        # pas de changement !        return directiondef maj_serpent(serpent, direction, serpent2):    """    permet de genere de nouvelle    boulle pour le corps, et    prend en argument le serpent lorsque que le mode    2 joueur est activé, et la direction    pour fait deplacer le corps du serpent,    et permet de faire perdre le joueur    si ça touche le bords de l'ecran    ou touche ça propre queue    """    x_tete, y_tete = serpent[-1] # sauvegarde la premiere tete    x = x_tete + direction[0]    y = y_tete + direction[1]    if y < 0 or x < 0 or y > 29 or x > 39 :        return False    elif (x, y) in serpent and len(serpent) > 1: # se mange la queue        return False    elif (x, y) in serpent2:        return False    elif (x, y) in obstacles:        return False    elif (x, y) in pommes :  # mange une pomme        pommes.remove((x, y))    else :        serpent.pop(0)  #suprime le 1er element    serpent.append((x_tete + direction[0], y_tete + direction[1]))    return Truedef ajoute_obstacle():    """    permet de generer un obstacle    au fur est a mesure du temps    """    while True:        simu = (randint(0, 39), randint(0, 29))        if simu not in serpent and simu not in obstacles and simu not in pommes:            obstacles.append(simu)            return Nonedef ajoute_pomme():    """    permet de generer une nouvelle    pomme lorsque qu'une pomme    est manger    """    while True :        simu = (randint(0, 39), randint(0, 29))        if simu not in serpent and simu not in pommes and simu not in obstacles:            pommes.append(simu)            return Nonedef sur_bouton(bouton, click):    """    permet de generer un bouton    ou on peut cliqué dessus    """    topx, topy = bouton[0]    basx, basy = bouton[1]    return topx <= click[0] <= basx and topy <= click[1] <= basydef nettoie_fenetre():    """    permet de faire les transition entre    chacune des image en netooyant    la fenetre    """    # nettoyage de la fenêtre    efface_tout()    rectangle(0,0,              taille_case*largeur_plateau,              taille_case*largeur_plateau,              remplissage='black')# dimensions du jeutaille_case = 15largeur_plateau = 40  # en nombre de caseshauteur_plateau = 30  # en nombre de casesIMAGE = 'images.png' # image de iconfinderjouer = 'jouer.png'speed = 'rapide.png'jouer2 = 'deux.png'Imur = 'obstacles.png'normal = 'normal.png'vitesse = 0mur = FalseJ2 = False# programme principalif __name__ == "__main__":    # initialisation du jeu    framerate = 10   # taux de rafraîchissement du jeu en images/s    direction = (0, 0)  # direction initiale du serpent    direction2 = (0, 0)    pommes = [] # liste des coordonnées des cases contenant des pommes    serpent = [(0, 0)] # liste des coordonnées de cases adjacentes décrivant le serpent    serpent2 = [(39, 29)]    obstacles = []    # menu    cree_fenetre(taille_case * largeur_plateau,                 taille_case * hauteur_plateau)    image(301, 200, IMAGE, ancrage = 'center')    image(10, 200, jouer, ancrage='nw')    image(10, 288, jouer2, ancrage ='nw')    mise_a_jour()    playBtn = [(10,200), (156,258)]    twoPlayersBtn = [(10,288), (222,344)]    while True :     click = attend_clic_gauche()     if sur_bouton(playBtn, click):         break     elif sur_bouton(twoPlayersBtn, click):         J2 = True         nettoie_fenetre()         texte(0, 0, 'Joueur 1 :', couleur='pink', ancrage='nw', taille = 30)         texte(0, 40, 'Pour jouer vous devez utiliser :', couleur='pink',                  ancrage='nw', taille = 30)         texte(0, 80, "la touche 'Q' pour aller à gauche",                  couleur='pink', ancrage='nw', taille = 30)         texte(0, 120, "la touche 'D' pour aller à droite",                  couleur='pink', ancrage='nw', taille = 30)         texte(0, 160, "la touche 'S' pour aller en bas",                  couleur='pink', ancrage='nw', taille = 30)         texte(0, 200, "la touche 'Z' pour aller en haut",                  couleur='pink', ancrage='nw', taille = 30)         texte(0, 240, "si vous avez compris cliquez sur la fenètre ",               couleur='red', ancrage='nw', taille= 24)         texte(0, 280, 'sinon relisez', couleur='red', ancrage='nw',               taille=30)         mise_a_jour()         attend_clic_gauche()         break    efface_tout()    image(301, 200, IMAGE, ancrage = 'center')    image(10, 230, normal, ancrage= 'nw')    image(10, 288, Imur, ancrage ='nw')    image(10, 340, speed, ancrage='nw')    mise_a_jour()    # Definition des boutons du menu    wallBtn = [(10, 288), (216, 340)]    playFasterBtn = [(10, 340), (285, 394)]    normalBtn = [(10, 230), (187, 287)]    while True :     click = attend_clic_gauche()     if sur_bouton(wallBtn, click):         mur = True         break     elif sur_bouton(playFasterBtn, click):         vitesse = 1         break     elif sur_bouton(normalBtn, click):         break    # boucle principale    jouer = True    cmpt = 0    while jouer:        nettoie_fenetre()        # affichage des objets        affiche_pommes(pommes)        affiche_serpent(serpent, 'green')        if J2:            affiche_serpent(serpent2, 'red')        if mur :            affiche_obstacles(obstacles)        mise_a_jour()        # gestion des événements        ev = donne_ev()        if ev != None:            ty = type_ev(ev)            if ty == 'Quitte':                jouer = False                continue            elif ty == 'Touche':                key = touche(ev)                if J2:                    direction = change_direction2(direction, key)                    direction2 = change_direction(direction2, key)                else :                    direction = change_direction(direction, key)        if cmpt == 20:            if mur :                a = randint(1, 4)                if a == 1:                    ajoute_obstacle()                else :                    ajoute_pomme()                cmpt = 0            else:                ajoute_pomme()                cmpt = 0        if vitesse == 1:            framerate = (len(serpent) + 10) * 2        cmpt += 1        if not maj_serpent(serpent, direction, serpent2):            v = 1            jouer = False        elif not maj_serpent(serpent2, direction2, serpent):            v = 2            jouer = False        # attente avant rafraîchissement        sleep(1/framerate)    if not J2 :        texte(400, 10,f"Score = {len(serpent)-1}", couleur='pink',               ancrage='nw', taille=30)        texte(200, 200, 'TOO BAD :(', couleur='pink',                      ancrage='center', taille=24  )    else :        if v == 1 :            texte(200, 200, 'Bravo joueur 2', couleur='pink',                      ancrage='center', taille=24  )        else :            texte(200, 200, 'Bravo joueur 1', couleur='pink',                      ancrage='center', taille=24  )    mise_a_jour()    attend_ev()    # fermeture et sortie    ferme_fenetre()